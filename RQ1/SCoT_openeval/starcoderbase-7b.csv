"Input: arr: an array of integers, N: length of the array, K: a number
Output: count: the number of elements that when increased by K, would be greater than the sum of all the other elements in the array.
1: sum = 0
2: for i in range(N):
3:     sum += arr[i]
4: count = 0
5: for i in range(N):
6:     if arr[i] + K > sum:
7:         count += 1
8: return count"
"Input: arr: an array of integers, n: length of array
Output: freq: frequency of the minimum value in the array
1: freq = 1
2: for i in range(n):
3:     if arr[i] < arr[0]:
4:         freq += 1
5: return freq"
"Input: n: an integer, l: an integer, r: an integer
Output: ""Yes"" or ""No""
1: if n is less than 0 or greater than 2^31 - 1:
2:     return ""No""
3: if l is less than 0 or greater than 31:
4:     return ""No""
5: if r is less than 0 or greater than 31:
6:     return ""No""
7: if l > r:
8:     return ""No""
9: if n = 0:
10:    return ""Yes""
11: if n = 1:
12:    return ""Yes""
13: if n = 2:
14:    return ""Yes""
15: if n = 3:
16:    return ""Yes""
17: if n = 4:
18:    return ""Yes""
19: if n = 5:
20:    return ""Yes""
21: if n = 6:
22:    return ""Yes"""
"Input: A: an array of integers, n: length of A, K: integer
Output: count: number of pairs whose sum is divisible by K
1: count = 0
2: for i = 0 to n-1:
3:     for j = i+1 to n-1:
4:         if A[i] + A[j] % K == 0:
5:             count = count + 1
6: return count"
"Input: n: an integer, a: a list of integers
Output: boolean
1: if n is less than or equal to 0:
2:     return False
3: if n is greater than the length of a:
4:     return False
5: if n is equal to the length of a:
6:     return True
7: for i in range(0, n):
8:     if a[i] + a[n-i-1]!= 0:
9:         return False
10: return True"
"Input: x: an integer
Output: 1 or 0
1: if x is even:
2:     return 0
3: else:
4:     return 1"
"Input: vec: a list of integers
Output: list of missing elements
1: for each element i in vec:
2:     vec[abs(i)-1] = -vec[abs(i)-1]
3: for each element i in vec:
4:     if i > 0:
5:         missing_elements.append(abs(i)-1)
6: return missing_elements"
"Input: arr: an array of integers
Output: length of the longest subsequence
1: if arr is empty:
2:     return 0
3: dp[i] = 1 + dp[j] for all j < i such that arr[j] is a prefix of arr[i]
4: return max(dp)"
"Input: a: a list of integers
Output: a list of integers
1: for each integer i in a:
2:     count = 0
3:     for j in range(2,i):
4:         if i%j == 0:
5:             count += 1
6:     a[i-1] = count
7: return a"
"Input: arr: an array, n: length of the array, k: integer
Output: minimum difference
1: if k > n:
2:     return -1
3: if k == 1:
4:     return max(arr) - min(arr)
5: if k == n:
6:     return max(arr) - arr[0]
7: min_diff = max(arr) - arr[0]
8: for i in range(1, k):
9:     min_diff = min(min_diff, max(arr) - arr[i])
10: return min_diff"
"Input: A: list of integers, B: list of integers
Output: time: integer
1: time = 0
2: for each element a in A:
3:     for each element b in B:
4:         if a == b:
5:             time += 1
6:         else:
7:             B.remove(b)
8:             B.append(a)
9:             time += 2
10: return time"
"Input: array: an array of integers
Output: count: the count of even numbers in array
1: count = 0
2: for i in range(size):
3:     if array[i] % 2 == 0 and array[i]!= 0 and array[i]!= 2:
4:         count += 1
5: return count"
"Input: s: a string, k: an integer
Output: n: the number of substrings in s that contain at most k distinct characters
1: n = 0
2: for each character ch in s:
3:     if ch appears more than k times in s:
4:         break
5:     else:
6:         n = n + 1
7: return n"
"Input: n: an integer
Output: True or False
1: if n is 1:
2:     return True
3: if n is 2:
4:     return True
5: for i in range(2,n):
6:     if n % i == 0:
7:         return False
8: return True"
"Input: n: an integer
Output: XOR: the XOR of n with a specific pattern
1: if n is 0:
2:     return n
3: elif n is 1:
4:     return 1
5: elif n is 2:
6:     return n + 1
7: elif n is 3:
8:     return 0
9: else:
10:     return """""
"Input: n: a positive integer
t: a positive integer
Output: 1 or -1
1: if n is not a positive integer:
2:     return -1
3: if t is not a positive integer:
4:     return -1
5: if n is less than 2:
6:     return -1
7: if n is equal to 2:
8:     return 1
9: if n is equal to 3:
10:     return 1
11: if n is equal to 5:
12:     return 1
13: if n is equal to 7:
14:     return 1
15: if n is equal to 11:
16:     return 1
17: if n is equal to 13:
18:     return 1
19: if n is equal to 17:
20:     return 1
21: if n is equal to 19:
22:     return 1
23: if n is equal to 23:
24:     return"
"Input: s1: a string, s2: a string, n: an integer
Output: a boolean
1: for i in range(n):
2:     if s1[i] == '0' and s2[i] == '1' or s1[i] == '1' and s2[i] == '0' or s1[i] == '0' and s2[i] == 'Z' or s1[i] == 'Z' and s2[i] == '0':
3:         return True
4: return False"
"Input: a, b, c, d, x
Output: result
1: result = (x * (a + b) * (c - d)) / ((a * d) - (b * c))
2: return result"
"Input: s: a string
Output: min: the minimum number of replacements needed to make the string alternate between '0' and '1'
1: count = 0
2: for i in range(len(s)):
3:     if i % 2 == 0 and s[i] == '1':
4:         count += 1
5:     elif i % 2 == 1 and s[i] == '0':
6:         count += 1
7: min = min(count, len(s) - count)
8: return min"
"Input: n: an integer
Output: count: the number of power numbers less than or equal to n
1: count = 0
2: for i in range(1, n+1):
3:     if math.log(i) / math.log(2) == math.floor(math.log(i) / math.log(2)):
4:         count += 1
5: return count"
"Input: x: a number, y: a number
Output: product: the product of x and y
1: if y == 0:
2:     return 1
3: else:
4:     return x + product(x, y-1)"
"Input: a: a list of integers
Output: 1 or 2
1: count0 = 0
2: count1 = 0
3: count2 = 0
4: count3 = 0
5: for i in range(len(a)):
6:     if a[i] % 4 == 0:
7:         count0 += 1
8:     elif a[i] % 4 == 1:
9:         count1 += 1
10:     elif a[i] % 4 == 2:
11:         count2 += 1
12:     else:
13:         count3 += 1
14: if count0 % 2 == 0 and count1 % 2 == 0 and count2 % 2 == 0 and count3 % 2 == 0:
15:     return 1
16: else:
17:     return 2"
"Input: arr: an array of integers, n: size of the array
Output: length of the longest increasing subarray
1: max_ending_here = 0
2: max_so_far = 0
3: for i = 0 to n-1:
4:     max_ending_here = max_ending_here + arr[i]
5:     if max_so_far < max_ending_here:
6:         max_so_far = max_ending_here
7:     if max_ending_here < 0:
8:         max_ending_here = 0
9: return max_so_far"
"Input: arr: an array of integers, n: the length of the array, i: the current index, sum: the target sum, count: the count
Output: count: the number of subsets of the array that sum up to the target sum
1: if i == n:
2:     if sum == 0:
3:         count += 1
4:     return count
5: return subsetSum(arr, n, i + 1, sum - arr[i], count) + subsetSum(arr, n, i + 1, sum, count)"
"Input: n: an integer
Output: center_hex: the center hexadecagonal number for n
1: if n is even:
2:     center_hex = n * 2 - 1
3: else:
4:     center_hex = n * 2
5: return center_hex"
"Input: n: an integer
Output: sum_of_squares: the sum of the squares of the first n natural numbers
Output: sum_of_n: the sum of the first n natural numbers
Output: sum_of_squares_plus_1: the sum of the squares of the first n natural numbers, the sum of the first n natural numbers, and adds 1 to the total sum.
1: sum_of_squares = 0
2: sum_of_n = 0
3: for i in range(1, n+1):
4:     sum_of_squares = sum_of_squares + i**2
5:     sum_of_n = sum_of_n + i
6: sum_of_squares_plus_1 = sum_of_squares + sum_of_n + 1
7: return sum_of_squares, sum_of_n, sum_of_squares_plus_1"
"Input: n: an integer
Output: maxSum: the maximum sum of all the factors of n
1: maxSum = 0
2: for i in range(1, n+1):
3:     if n % i == 0:
4:         maxSum += i
5: return maxSum"
"Input: x, y: two numbers
Output: True or False
1: if x <= y:
2:     return True
3: return False"
"Input: n: an integer
Output: center_octadecagon_num: the center octadecagon number of n
1: return 9 * n * n - 9 * n + 1"
"Input: a: a number, b: a number
Output: percentage: a number
1: percentage = (b-a)/a
2: return percentage"
"Input: n: an integer
Output: avg: the average of the squares of the first n natural numbers
1: sum = 0
2: for i in range(1, n+1):
3:     sum = sum + i**2
4: avg = sum / n
5: return avg"
"Input: arr: an array, n: length of the array, k: the kth smallest element
Output: kth smallest element in the array
1: sort the array
2: return the kth smallest element"
"Input: n: an integer
Output: chicks: the number of chicks
1: chicks = 3**n-1
2: return chicks"
"Input: n: an integer
Output: nth term of the sequence
1: if n = 1:
2:     return 1
3: elif n = 2:
4:     return 2
5: else:
6:     return findTerm(n-1)*2 + n-1"
"Input: a: a list of integers, k: an integer
Output: an integer
1: if a is empty:
2:     return 0
3: if k is 0:
4:     return 1
5: if a[0] * a[1] < k:
6:     return 1 + countSubArrayProductLessThanK(a[1:], k)
7: return countSubArrayProductLessThanK(a[1:], k)"
"Input: n: a positive integer, d: a digit
Output: count: a positive integer
1: count = 0
2: for i in range(1, n + 1):
3:     if i % 10 == d:
4:         count += 1
5: return count"
"Input: arr: an array of integers, n: length of array
Output: smallest positive integer that is missing from the array
1: for i = 0 to n-1:
2:     if arr[i] > 0 and arr[i] <= n and arr[i] not in arr:
3:         return arr[i]
4: return -1"
"Input: n: an integer
Output: an integer
1: if n = 1:
2:     return 1
3: elif n = 2:
4:     return 2
5: else:
6:     return ways(n-1) + ways(n-2)"
"Input: l: length of the rectangle, b: breadth of the rectangle
Output: area: sum of the areas of all the squares that can fit inside the rectangle
1: area = 0
2: for i in range(1, l + 1):
3:     area += i * i
4: for i in range(1, b + 1):
5:     area += i * i
6: return area"
"Input: N: an integer
Output: sum: the sum of all numbers from 1 to N
1: sum = 0
2: for i in range(1, N+1):
3:     sum = sum + i
4: return sum"
"Input: arr: an array of integers, n: the length of the array
Output: max_consecutive_zeros: the maximum number of consecutive zeros between two ones in the array
1: max_consecutive_zeros = 0
2: for i in range(n):
3:     if arr[i] == 1:
4:         max_consecutive_zeros += 1
5:     else:
6:         max_consecutive_zeros = 0
7: return max_consecutive_zeros"
"Input: arr: an array of integers
Output: length: length of the longest subarray that contains at least one zero
1: max_ending_here = 0
2: max_so_far = 0
3: for i in range(n):
4:     max_ending_here = max_ending_here + arr[i]
5:     if max_ending_here < 0:
6:         max_ending_here = 0
7:     max_so_far = max(max_so_far, max_ending_here)
8: return max_so_far"
"Input: a: an array of integers, n: length of the array, k: segment size
Output: max: maximum value of the minimum elements in each segment of size 'k' in the array.
1: max = a[0]
2: for i in range(1, n - k + 1):
3:     min = a[i]
4:     for j in range(i + 1, i + k):
5:         if a[j] < min:
6:             min = a[j]
7:     if min > max:
8:         max = min
9: return max"
"Input: array: a list of integers, n: length of array, k: integer
Output: count: number of subarrays whose product is less than or equal to k
1: count = 0
2: for i in range(n):
3:     for j in range(i, n):
4:         count += 1
5:         if array[j] * (j - i + 1) > k:
6:             break
7: return count"
"Input: arr: an array, n: an integer
Output: sum of absolute differences between each element in the sorted array and its corresponding index plus one
1: sort arr
2: sum = 0
3: for i in range(n):
4:     sum += abs(arr[i] - i) + 1
5: return sum"
"Input: arr: an array of integers, n: the length of the array
Output: min_element: the minimum element in arr
1: min_element = arr[0]
2: for i in range(1, n):
3:     if arr[i] < min_element:
4:         min_element = arr[i]
5: return min_element * (n - 1)"
"Input: array: an array of integers
Output: max_distance: the maximum difference between any two elements in the array
1: max_distance = 0
2: for i in range(len(array)):
3:     for j in range(i+1, len(array)):
4:         distance = abs(array[i] - array[j])
5:         if distance > max_distance:
6:             max_distance = distance
7: return max_distance"
"Input: a, b, c, x1, y1, x2, y2
Output: True or False
1: if a = 0:
2:     if b = 0:
3:         return False
4:     else:
5:         return (x1 * b - y1 * c) * (x2 * b - y2 * c) <= 0
6: else:
7:     return (x1 * a - y1 * c) * (x2 * a - y2 * c) <= 0"
"Input: a: an integer
Output: count: the number of solutions to the equation a = i + (a XOR i), where i ranges from 0 to a (inclusive)
1: count = 0
2: for i in range(a + 1):
3:     if a ^ i == i:
4:         count = count + 1
5: return count"
"Input: L: an integer, R: an integer
Output: max_AND: an integer
1: max_AND = 0
2: for i in range(32):
3:     if L & (1 << i) > max_AND:
4:         max_AND = L & (1 << i)
5: if max_AND == 0:
6:     return R
7: return max_AND"
"Input: a: an array of integers, n: the length of the array
Output: smallest: the smallest number in the array that is a factor of all other numbers in the array
1: smallest = a[0]
2: for i = 1 to n-1:
3:     if a[i] % smallest == 0:
4:         smallest = a[i]
5: return smallest"
"Input: n: an integer
Output: sum: the sum of the series 1/3^n for n terms
1: sum = 0
2: for i in range(n):
3:     sum = sum + 1/3^i
4: return sum"
"Input: arr: a 2D array, n: an integer
Output: xor: the XOR of all submatrices of size (i+1) x (j+1) where i and j range from 0 to n-1
1: xor = 0
2: for i in range(n):
3:     for j in range(n):
4:         if (i+1)*(j+1) % 2 == 1:
5:             xor ^= arr[i][j]
6: return xor"
"Input: N: an integer
Output: count: the count of numbers from 0 to N (inclusive) where the bitwise XOR of the number with its own bitwise OR is equal to the number itself.
1: count = 0
2: for i in range(N+1):
3:     if (i ^ i | i) == i:
4:         count += 1
5: return count"
"Input: a: an array of integers, n: the length of the array, k: an integer
Output: True or False
1: sum = 0
2: for i = 0 to n - 1:
3:     sum = sum + a[i]
4: if sum + n - 1 = k:
5:     return True
6: return False"
"Input: n: an integer
Output: True or False
1: if n is 0:
2:     return True
3: if n is 1:
4:     return True
5: if n is 2:
6:     return False
7: if n is 3:
8:     return True
9: if n is 4:
10:     return False
11: if n is 5:
12:     return True
13: if n is 6:
14:     return False
15: if n is 7:
16:     return True
17: if n is 8:
18:     return False
19: if n is 9:
20:     return True
21: if n is 10:
22:     return False
23: if n is 11:
24:     return True
25: if n is 12:
26:     return False
27: if n is 13:
28:     return True
29: if n is 14"
"Input: s: a string
Output: max_part: the maximum number of partitions
1: max_part = 1
2: for i = 1 to len(s) - 1:
3:     if s[i] == s[i - 1]:
4:         max_part += 1
5: return max_part"
"Input: N: an integer, K: an integer
Output: N: an integer
1: if N is divisible by K:
2:     return N
3: else:
4:     return N - N % K"
"Input: arr: an array of integers, N: an integer
Output: result: the result of the successive change calculation
1: result = 0
2: var1 = arr[0]
3: var2 = arr[1]
4: for i in range(2,N):
5:     result = result + var1 + var2 + (var1*var2)/100
6:     var1 = var2
7:     var2 = arr[i]
8: return result"
"Input: arr: an array, ranges: a list of ranges, reversals: the number of reversals, index: the index
Output: the value at the given index after performing the specified number of reversals on the array.
1: for each range in ranges:
2:     swap the elements within the range
3: return arr[index]"
"Input: n: an integer
Output: True or False
1: if n < 0:
2:     return False
3: if n == 0:
4:     return True
5: for i in range(1, int(n**0.5)+1):
6:     if n == i**2 + i**2:
7:         return True
8: return False"
"Input: a: string, b: string
Output: int
1: if len(a) > len(b):
2:     return -1
3: if len(a) == 0:
4:     return 0
5: if b[0] == a[0]:
6:     return getCount(a[1:], b[1:]) + 1
7: return getCount(a[1:], b)"
"Input: str: a string, len: a positive integer
Output: str: a modified string
1: if len < 2:
2:     return str
3: else:
4:     for i in range(len-2,-1,-1):
5:         if str[i] > str[i+1]:
6:             str[i] -= 1
7:             str[i+1:] = '9' * (len-i-1)
8:     return str"
"Input: arr: an array of numbers, n: length of the array
Output: min_value: the minimum value of the array
1: min_value = arr[0]
2: for i in range(1, n):
3:     if arr[i] < min_value:
4:         min_value = arr[i]
5: return min_value"
"Input: str: a string
Output: str: the largest substring of str that does not end with '1'
1: if str is empty or consists only of '1' characters:
2:     return -1
3: max_len = 0
4: start = 0
5: end = 0
6: for i in range(len(str)):
7:     if str[i] == '1':
8:         end = i
9:         if end - start + 1 > max_len:
10:             max_len = end - start + 1
11:             start = i + 1
12: return str[start:end+1]"
"Input: a: an array, n: the length of a, k: an integer
Output: length of the modified array
1: if n <= k:
2:     return 0
3:     else:
4:         for i in range(n):
5:             if a[i] == min(a):
6:                 a.remove(a[i])
7:                 n = n - 1
8:                 k = k - 1
9:                 return MinRemove(a, n, k)
10: return n"
"Input: arr: an array, n: size of the array, k: number of elements to be added to the array
Output: max_median: maximum median of the array after adding k elements to it
1: size_after_adding_k_elements = n + k
2: if size_after_adding_k_elements is even:
3:     median = (arr[size_after_adding_k_elements/2] + arr[size_after_adding_k_elements/2 - 1])/2
4: else:
5:     median = arr[size_after_adding_k_elements/2]
6: arr.sort()
7: max_median = arr[k-1]
8: return max_median"
"Input: a: an array of integers
Output: n: the length of the array
1: step_count = 0
2: for each element a[i] in a:
3:     if a[i] == 1:
4:         step_count += 1
5:     elif a[i] == -1:
6:         step_count += abs(a[i] - 1)
7:     else:
8:         if (a[i] == 0 and i % 2 == 0) or (a[i] == 0 and i % 2!= 0 and a[i + 1] == 0):
9:             step_count += 1
10:         else:
11:             step_count += 2
12: return step_count"
"Input: n: an integer
Output: an integer
1: if n == 1:
2:     return 0
3: v = []
4: n = n - 1
5: while n > 0:
6:     v.append(n % 5)
7:     n = n // 5
8: result = 0
9: for i in reversed(v):
10:     result = result * 10 + i
11: return 2 * result"
"Input: n: an integer
Output: True or False
1: if n == 0:
2:     return True
3: else:
4:     return areSetBitsIncreasing(n/2) and (n%2 == 1)"
"Input: n: a positive integer, x: a positive integer
Output: closest multiple of x to n
1: if x is greater than n:
2:     return x
3: else:
4:     return n * (x // n)
5: if (x % n) > (n // 2):
6:     return n * (x // n) + x
7: else:
8:     return n * (x // n)"
"Input: n: an integer
Output: sum: the sum of the series
1: sum = 0
2: for i in range(n):
3:     sum = sum + 2
4: return sum"
"Input: n: an integer
Output: sum: the sum of the series
1: sum = 0
2: for i in range(1, n+1):
3:     sum += 2**i
4: return sum"
"Input: arr: an array, n: length of the array
Output: maxm: the maximum value in the array that occurs the same number of times as its value.
1: maxm = -1
2: for i = 0 to n-1:
3:     if arr[i] == maxm:
4:         maxm += 1
5:     else:
6:         maxm = arr[i]
7: return maxm"
"Input: a: a list of integers
Output: n: the length of the list
1: count = 0
2: for i in range(n):
3:     for j in range(i+1, n):
4:         if a[i] == 2**j:
5:             count += 1
6: return count"
"Input: n: an integer
Output: n: the result of toggling all the bits in the binary representation of n
1: return n ^ ( n - 1 )"
"Input: A: a list of integers
n: length of list A
Output: minimum number of changes
1: count = 0
2: for i in range(n-1):
3:     if A[i] == 1 and A[i+1] == 1:
4:         A[i+1] = 0
5:         count += 1
6: return count"
"Input: radian: a float
Output: degree: a float
1: degree = radian * 180 / pi
2: return degree"
"Input: n: an integer
Output: n//2: the floor division of n by 2"
"Input: a: int, d: int, n: int
Output: sum: int
1: sum = a
2: for i in range(1, n):
3:     sum = sum + d
4: return sum"
"Input: n: an integer
Output: largest power of 2 that divides n
1: if n is odd:
2:     return 1
3: else:
4:     return 2**int(log2(n))"
"Input: row: an integer, column: an integer, moves: an integer
Output: an integer
1: if moves == 0:
2:     return 1
3: elif moves == 1:
4:     return 2
5: elif moves == 2:
6:     return 4
7: elif moves == 3:
8:     return 8
9: elif moves == 4:
10:     return 16
11: elif moves == 5:
12:     return 32
13: elif moves == 6:
14:     return 64
15: elif moves == 7:
16:     return 128
17: elif moves == 8:
18:     return 256
19: else:
20:     return 512"
"Input: n: an integer
Output: n: the next number in the sequence
1: if n is 0:
2:     return 1
3: return n + findNumber(n-1)"
"Input: str: a string
Output: str: a string with the smallest lexicographically possible permutation
1: last_occurrence = [0] * 26
2: for i in range(len(str)):
3:     last_occurrence[ord(str[i]) - ord('a')] = i
4: str = sorted(str)
5: for i in range(len(str)):
6:     if ord(str[i]) - ord('a')!= last_occurrence[ord(str[i]) - ord('a')]:
7:         str = str[:i] + str[last_occurrence[ord(str[i]) - ord('a')] - i] + str[i + 1:]
8: return str"
"Input: n: an integer, l: an integer, r: an integer
Output: sum: an integer
1: arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99]
2: sum = 0
3: for i in range(l-1, r):
4:     sum = sum + arr[i"
"Input: x: an integer, y: an integer
Output: hcf: the highest common factor of x and y
1: min = min(x,y)
2: if min % x == 0 and min % y == 0:
3:     return min
4: for i in range(min//2, 1, -1):
5:     if min % i == 0 and x % i == 0 and y % i == 0:
6:         return i
7: return 1"
"Input: A: an integer, B: an integer, N: an integer
Output: an integer
1: if N = 1:
2:     return A
3: elif N = 2:
4:     return B
5: else:
6:     return findNthNumber(A + B, A, N - 1)"
"Input: str: a string, substr: a string
Output: num: an integer
1: num = 0
2: for i in range(len(str)):
3:     if str[i] == substr[0]:
4:         if str[i:i+len(substr)] == substr:
5:             num += 1
6: return num"
"Input: p: principal amount, r: annual interest rate, t: loan tenure
Output: emi: equated monthly installment
1: r = r / 12 / 100
2: t = t * 12
3: emi = p * r * (1 + r)**t / ((1 + r)**t - 1)
4: return emi"
"Input: A: an integer
B: an integer
C: an integer
Output: an integer
1: if A > B:
2:     A, B = B, A
3: if B > C:
4:     B, C = C, B
5: if A > B:
6:     A, B = B, A
7: if B > C:
8:     B, C = C, B
9: if A > B:
10:     A, B = B, A
11: if B > C:
12:     B, C = C, B
13: if A > B:
14:     A, B = B, A
15: if B > C:
16:     B, C = C, B
17: if A > B:
18:     A, B = B, A
19: if B > C:
20:     B, C = C, B
21: if A > B:
22:     A, B = B, A
23: if B > C:
24"
"Input: l: lower bound, r: upper bound
Output: count: the count of numbers between l and r (inclusive) whose last digit is either 2, 3, or 9.
1: count = 0
2: for i in range(l, r+1):
3:     if i % 10 == 2 or i % 10 == 3 or i % 10 == 9:
4:         count += 1
5: return count"
"Input: n: an integer
Input: arr: a list of integers
Output: length: an integer
1: if n == 0 or arr == []:
2:     return 0
3: if n == 1:
4:     return 1
5: if n == 2:
6:     return 2
7: if n == 3:
8:     return 3
9: if n == 4:
10:     return 4
11: if n == 5:
12:     return 5
13: if n == 6:
14:     return 6
15: if n == 7:
16:     return 7
17: if n == 8:
18:     return 8
19: if n == 9:
20:     return 9
21: if n == 10:
22:     return 10
23: if n == 11:
24:     return 11
25: if n == 12:
26:     return"
"Input: str: a string
Output: max_len_even_str: a string
1: max_len_even_str = """"
2: for each character ch in str:
3:     if ch is an alphabetic character:
4:         if len(max_len_even_str) % 2 == 0:
5:             max_len_even_str += ch
6:         else:
7:             max_len_even_str = max_len_even_str[0:-1] + ch
8: return max_len_even_str"
"Input: n: an integer
Output: count: an integer
1: count = 0
2: while n > 1:
3:     count = count + 1
4:     n = n / 2
5: return count"
"Input: n: an integer, k: an integer
Output: a string of length n
1: create a string of length n consisting of all 'a' characters
2: for each character in the string:
3:     if k is greater than or equal to 0:
4:         if k is greater than or equal to 26:
5:             replace the character with 'z'
6:             k = k - 26
7:         else:
8:             replace the character with the corresponding lowercase letter
9:             k = k - (ord(character) - 97 + 26)
10:     else:
11:         exit the loop
12: return the modified string"
"Input: n: number of stops
fuel: amount of fuel available
Output: total distance covered
1: total_distance = 0
2: for i in range(n):
3:     total_distance += fuel / n
4:     fuel -= total_distance
5: return total_distance"
"Input: arr: an array of integers, n: the length of the array
Output: 1 if there exists a split point in the array such that the sum of the elements before the split point is equal to one-third of the total sum of the array and the sum of the elements after the split point is equal to two-thirds of the total sum of the array.
0 if there does not exist such a split point."
"Input: sentence: a string, word: a string
Output: True or False
1: for each character ch in word:
2:     if ch not in sentence:
3:         return False
4: return True"
"Input: n: an integer
Output: count: the number of digits in n
1: count = 0
2: while n > 0:
3:     count = count + 1
4:     n = n // 10
5: return count"
"Input: a, b, c, k
Output: boolean
1: if a + k = b and b + k = c:
2:     return True
3: elif a - k = b and b - k = c:
4:     return True
5: else:
6:     return False"
"Input: x: an integer, y: an integer
Output: boolean
1: if x == y:
2:     return True
3: if x < y:
4:     return False
5: x = x << 1
6: while x <= y:
7:     if x == y:
8:         return True
9:     if x > y:
10:         return False
11:     x = x << 1
12: return False"
"Input: str: a string
Output: int: the number of consecutive characters that are not the same
1: count = 0
2: for i in range(len(str)):
3:     if str[i]!= str[i+1]:
4:         count += 1
5: return count"
"Input: string: a string, n: an integer
Output: count: an integer
1: count = 0
2: for i in range(n):
3:     if string[i] == '0':
4:         count += 1
5:     else:
6:         count += 2
7: return count"
"Input: arr: an array of integers
Output: min_removal: minimum number of elements that need to be removed from the array such that the absolute difference between adjacent elements is minimized.
1: min_removal = 0
2: for i = 0 to n-2:
3:     if abs(arr[i] - arr[i+1]) < abs(arr[min_removal] - arr[min_removal+1]):
4:         min_removal = i
5: return min_removal + 1"
"Input: left: an integer, right: an integer
Output: an integer
1: max = 0
2: while left <= right:
3:     max = max + 1
4:     left = left + ( 1 << max )
5: return max"
"Input: n: an integer
Output: next_power: the next power of 2 that is greater than or equal to n
1: if n is a power of 2:
2:     return n
3: else:
4:     return 2 * next_power"
"Input: n: an integer
Output: True or False
1: sum = 0
2: for i in range(1, n+1):
3:     if n % i == 0:
4:         sum = sum + i
5:     if sum == n:
6:         return True
7: return False"
"Input: N: a year
Output: odd_days: the number of odd days in the year
1: if N is less than or equal to 0:
2:     return 0
3: if N is greater than or equal to 1700:
4:     return 0
5: if N is greater than or equal to 1800:
6:     return 1
7: if N is greater than or equal to 1900:
8:     return 1
9: if N is greater than or equal to 2000:
10:     return 1
11: if N is greater than or equal to 2100:
12:     return 1
13: if N is greater than or equal to 2200:
14:     return 1
15: if N is greater than or equal to 2300:
16:     return 1
17: if N is greater than or equal to 2400:
18:     return 1
19: if N is greater than or equal to"
"Input: a: a number
Output: length: the length of the pentagonal diagonal
1: if a < 0:
2:     return -1
3: length = 1
4: while length < a:
5:     length += 1
6:     length += length - 1
7: return length"
"Input: n: a positive integer, d: a digit
Output: frequency of d in n
1: frequency = 0
2: while n > 0:
3:     if n % 10 == d:
4:         frequency += 1
5:     n = n // 10
6: return frequency"
"Input: n: an integer
Output: True or False
1: if n is less than 10:
2:     return True
3: if n is divisible by 10:
4:     return False
5: else:
6:     return validate(n//10) and validate(n%10)"
"Input: a: a list of integers
n: an integer
Output: boolean
1: for each element in a:
2:     if element % 5 == 0 and element % 3 == 0:
3:         element = element / 5
4:         element = element / 3
5:     if element!= n:
6:         return False
7: return True"
"Input: n: an integer
Output: an integer
1: if n < 0:
2:     return None
3: if n == 0:
4:     return 4
5: if n == 1:
6:     return 7
7: if n % 2 == 0:
8:     return printNthElement(n//2)*10 + 7
9: return printNthElement(n//2)*10 + 4
10: return None"
"Input: n: an integer
Output: nth element of the array
1: array = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0"
"Input: n: an integer
Output: nth: an integer
1: nth = 1
2: for i in range(2, n+1):
3:     if i % 2 == 0:
4:         nth = nth * 10 + 2
5:     else:
6:         nth = nth * 10 + 1
7: return nth"
"Input: a: an array of integers, n: the length of the array
Output: True or False
1: if n is less than 2:
2:     return False
3: if a[0] is not 0:
4:     return False
5: for i in range(1, n):
6:     if a[i] is not 0:
7:         if a[i] % 11 is not 0:
8:             return False
9: return True"
"Input: l: length, b: breadth, h: height
Output: area: area of the square
1: if l < 0 or b < 0 or h < 0:
2:     return -1
3: return l * b * h"
"Input: str: a string
Output: str: a string
1: for each word in str:
2:     if word is not empty:
3:         word[0] = word[0].upper()
4:         word[-1] = word[-1].upper()
5: return str"
"Input: p: an integer
Output: bucketNo: an integer
1: bucketNo = math.ceil(math.sqrt(8 * p + 1) - 1) / 2
2: return bucketNo"
"Input: arr: an array
Output: True or False
1: for i in range(len(arr)):
2:     for j in range(i+1, len(arr)):
3:         if arr[i] == arr[j]:
4:             return False
5: return True"
"Input: string: a string
Output: count: a count of distinct two-character codes in string
1: count = 0
2: for i in range(len(string)-1):
3:     if string[i] == string[i+1]:
4:         count += 1
5: return count"
"Input: lower: a number
Input: higher: a number
Output: mostCommon: the most common number between lower and higher
1: if lower == higher:
2:     return lower
3: elif lower > higher:
4:     return mostCommon( higher, lower )
5: else:
6:     if lower % 2 == 0:
7:         return mostCommon( lower + 1, higher )
8:     else:
9:         return mostCommon( lower + 2, higher )
10: return None"
"Input: str: a string
Output: max: the maximum number extracted from the string
1: max = 0
2: for each character ch in str:
3:     if ch is a digit:
4:         max = max * 10 + int(ch)
5:     else:
6:         max = max
7: return max"
"Input: s: a string, length: an integer
Output: longest: a substring of consecutive integers in s
1: longest = """"
2: for i in range(length):
3:     if s[i].isdigit():
4:         longest += s[i]
5:     else:
6:         if len(longest) > 0:
7:             return longest
8: return longest"
"Input: N: an integer
M: an integer
K: an integer
Output: an integer
1: while K > 0:
2:     if N > M:
3:         N = N - M
4:     else:
5:         M = M - N
6:     K = K - 1
7: if N == 0 or M == 0:
8:     return 0
9: else:
10:     return N * M"
"Input: string: a string, length: a positive integer
Output: True or False
1: if length is less than 2:
2:     return False
3: if string[0] == string[1]:
4:     return False
5: for i in range(2, length):
6:     if string[i] == string[i-1]:
7:         return False
8: return True"
"Input: n: an integer
Output: largest_power_of_2: the largest power of 2 that is less than or equal to n
1: if n is less than or equal to 1:
2:     return 1
3: else:
4:     return 2 * getValue(n/2)"
"Input: A: an integer
Input: B: an integer
Output: True or False
1: if len(str(A)) == len(str(B)):
2:     return True
3: else:
4:     return False"
"Input: x: an integer, y: an integer
Output: True or False
1: if x == y:
2:     return False
3: elif x - y == 1:
4:     return True
5: else:
6:     return False"
"Input: n: an integer
Output: str: a string
1: if n < 3:
2:     return ""1""
3: else:
4:     return tribWord(n-1) + tribWord(n-2) + tribWord(n-3)"
"Input: arr: an array of integers, n: the length of the array
Output: minSteps: an array of integers, each element is the minimum number of steps to reach the corresponding element in arr
1: minSteps[i] = minSteps[i-1] + abs(arr[i] - arr[i-1])
2: return minSteps"
"Input: n: an integer
Output: 0 or 1
1: if n % 4 == 0 or n % 4 == 3:
2:     return 0
3: elif n % 4 == 1 or n % 4 == 2:
4:     return 1
5: else:
6:     return None"
"Input: a: an integer, N: an integer
Output: ans: the sum of all multiples of a up to N
1: m = N / a
2: sum = (m * (m + 1)) / 2
3: ans = a * sum
4: return ans"
"Input: N: an integer
Output: an integer
1: if N <= 2:
2:     return N
3: elif N <= 4:
4:     return N + 3
5: elif (N - 4) % 4 == 0:
6:     return N + 1
7: elif (N - 4) % 4 <= 2:
8:     return N + 2
9: else:
10:     return N - 1"
"Input: arr: an array of integers
Output: True or False
1: if arr[0] % 2 == 1 and arr[n-1] % 2 == 1 and n % 2 == 1:
2:     return True
3: return False"
"Input: N: an integer
L: an integer
R: an integer
Output: count: an integer
1: if N is equal to 1:
2:     return R - L + 1
3: if N is greater than 1:
4:     return ( R - L + 1 ) * ( N - 1 ) + ( R - L + 1 )
5: return 0"
"Input: arr: an array of integers, n: length of the array
Output: smallest positive integer that is not present in the array
1: smallest = 1
2: for i = 0 to n-1:
3:     if arr[i] > 0 and arr[i] is not present in the array:
4:         smallest = arr[i]
5: return smallest"
"Input: s: a string, n: an integer
Output: smallestPoss: a number
1: if n == 0:
2:     return 0
3: if n == 1:
4:     return int(s)
5: if n == 2:
6:     return int(s[0]) * 10 + int(s[1])
7: if n > 2:
8:     return int(s[0]) * 10**(n-1) + smallestPoss(s[1:], n-1)
9: return None"
"Input: arr: an array of integers
Output: count: the total number of boxes removed
1: count = 0
2: for i in range(n):
3:     if arr[i] > arr[i-1]:
4:         count += arr[i] - arr[i-1]
5:     else:
6:         arr[i-1] = arr[i]
7: return count"
"Input: s: a string
Output: avg: the average value of the ASCII codes of the characters in s
1: sum = 0
2: for each character ch in s:
3:     sum = sum + ord(ch)
4: avg = sum / len(s)
5: return avg"
"Input: A: the value of each banknote
B: the value of each banknote
S: the desired amount
N: the number of banknotes
Output: the minimum number of banknotes needed, or -1 if it is not possible to reach the desired amount.
1: if S = 0:
2:     return 0
3: if S < 0:
4:     return -1
5: if S % B!= 0:
6:     return -1
7: return S // B + (S % B!= 0)"
"Input: x, y: two integers
Output: lcm(x, y): the least common multiple of x and y
1: if x == 0 or y == 0:
2:     return 0
3: if x == y:
4:     return x
5: if x > y:
6:     greater = x
7: else:
8:     greater = y
9: while True:
10:     if greater % x == 0 and greater % y == 0:
11:         return greater
12:     greater += 1"
"Input: n: an integer
Output: count: the number of trailing zeros in n's binary representation
1: count = 0
2: while n > 0:
3:     n = n // 5
4:     count = count + n
5: return count"
"Input: arr: an array of integers, n: length of array
Output: index: index of the element in the array such that the sum of the XOR of all elements to the left of it and the XOR of all elements to the right of it is maximum.
1: max_xor = 0
2: for i in range(n):
3:     left_xor = 0
4:     right_xor = 0
5:     for j in range(i):
6:         left_xor = left_xor ^ arr[j]
7:     for j in range(i+1,n):
8:         right_xor = right_xor ^ arr[j]
9:     max_xor = max(max_xor, left_xor + right_xor)
10: return max_xor"
"Input: arr: an array of integers, n: length of the array
Output: length of the longest decreasing subsequence
1: dp[i] = length of the longest decreasing subsequence ending at arr[i]
2: for i = 0 to n-1:
3:     dp[i] = 1
4: for i = 1 to n-1:
5:     for j = 0 to i-1:
6:         if arr[j] < arr[i]:
7:             dp[i] = max(dp[i], dp[j] + 1)
8: return max(dp)"
"Input: arr: an array, n: length of the array, k: value to be added or subtracted
Output: minimum element of the array plus k
1: if n == 0:
2:     return 0
3: if arr[0] == arr[n-1]:
4:     return arr[0] + k
5: if arr[0] + k == arr[n-1]:
6:     return arr[0] + k
7: if arr[0] - k == arr[n-1]:
8:     return arr[0] - k
9: return -1"
"Input: K: an integer
Output: length of the smallest repeating sequence of the number 1 when divided by K
1: if K is 0 or 1:
2:     return 0
3: if K is even:
4:     return 1 + numLen(K/2)
5: if K is odd:
6:     return 1 + numLen((3*K+1)/2)"
"Input: arr: an array, n: length of the array
Output: minimum number of operations
1: for i in range(n):
2:     if arr[i]!= arr[0]:
3:         if arr[i] > arr[0]:
4:             arr[i] -= 1
5:         else:
6:             arr[i] += 1
7: return i + 1"
"Input: n: an integer
Output: sum: the sum of the first n numbers in the sequence
1: if n is less than or equal to 0:
2:     return 0
3: else:
4:     return n + calSum(n-1)"
"Input: s: a number
Output: sqroot: the square root of s
1: if s < 0:
2:     return None
3: elif s == 0:
4:     return 0
5: else:
6:     return s ** 0.5"
"Input: p: a number
Output: q: a number
1: return (p**2 + q**2) / (p + q)"
"Input: str1: a string, len1: length of str1
Output: xor: the XOR of the ASCII values of all the characters in str1
1: xor = 0
2: for i in range(len1):
3:     xor = xor ^ ord(str1[i])
4: return xor"
"Input: n: an integer
Output: True or False
1: if n is 0:
2:     return True
3: if n is 1:
4:     return True
5: if n is even:
6:     return check_binary(n/2)
7: if n is odd:
8:     return check_binary(3*n+1)"
"Input: s: a string
Output: boolean: True or False
1: vowels = ['a', 'e', 'i', 'o', 'u']
2: for i in range(len(s)):
3:     if s[i] not in vowels:
4:         return False
5: return True"
"Input: low, high, k
Output: count of numbers between low and high (inclusive) whose last digit is greater than or equal to k
1: count = 0
2: for i in range(low, high+1):
3:     if i % 10 >= k:
4:         count += 1
5: return count"
"Input: n: an integer
Output: min_abs_diff: the minimum absolute difference between n and the nearest power of 2
1: if n is a power of 2:
2:     return 0
3: else:
4:     return min(abs(n - 2**k), abs(n - 2**(k+1)))
5: for k in range(math.floor(math.log2(n))):
6:     if n & (2**k) == 0:
7:         return min(abs(n - 2**k), abs(n - 2**(k+1)))
8: return min(abs(n - 2**k), abs(n - 2**(k+1)))"
"Input: r: a radius
Output: area: the area of a Reuleaux triangle with radius r
1: if r < 0:
2:     return -1
3: area = 3.14 * r * r
4: return area"
"Input: str: a string
Output: str: a new string
1: new_str = """"
2: for each character ch in str:
3:     new_str = new_str + ch
4: return new_str"
"Input: ar: an array of integers
Output: missing: the missing number
1: if ar[0]!= 1:
2:     return 1
3: if ar[size-1]!= size:
4:     return size
5: for i in range(1, size-1):
6:     if ar[i]!= i+1:
7:         return i+1
8: return None"
"Input: str: a string
Output: count: the number of occurrences of ""010"" in str
1: count = 0
2: for i in range(len(str)):
3:     if str[i:i+3] == ""010"":
4:         count += 1
5: return count"
"Input: arr: an array of integers
Output: first: the first element that appears an odd number of times
1: for i in range(0, n):
2:     if arr[i] % 2 == 1:
3:         first = arr[i]
4:         return first
5: return None"
"Input: arr: an array of integers, n: the length of the array
Output: xorArr: an array of integers, ans: an integer
1: xorArr = [0]*n
2: ans = 0
3: for i in range(n):
4:     xorArr[i] = arr[i] ^ ans
5:     ans = max(xorArr)
6: return ans"
"Input: sx, sy, dx, dy: integers
Output: True or False
1: if sx == dx and sy == dy:
2:     return True
3: if sx == dx or sy == dy:
4:     return False
5: if sx < dx and sy < dy:
6:     return isReachable(sx + 1, sy + 1, dx, dy)
7: if sx > dx and sy > dy:
8:     return isReachable(sx - 1, sy - 1, dx, dy)
9: if sx < dx and sy > dy:
10:     return isReachable(sx + 1, sy - 1, dx, dy)
11: if sx > dx and sy < dy:
12:     return isReachable(sx - 1, sy + 1, dx, dy)"
"Input: n: an integer
Output: an integer
1: if n is odd:
2:     return 0
3: return 1 + cntWays(n/2)"
"Input: arr: an array of integers, n: the length of the array
Output: count: the count of all possible subsequences in the array
1: count = 1
2: for i in range(n):
3:     count = count * (len(arr) - i)
4: return count"
"Input: height: an integer
Output: number of nodes in an AVL tree of that height
1: if height = 0:
2:     return 0
3: else:
4:     return 2 * AVLnodes(height-1) + 1"
"Input: source: starting point, step: step size, dest: destination point
Output: number of steps
1: if source == dest:
2:     return 0
3: elif source > dest:
4:     return steps(source-step, step, dest) + 1
5: else:
6:     return steps(source+step, step, dest) + 1
7: return sys.maxsize"
"Input: n: an integer
Output: str: the nth term of the ""Count and Say"" sequence
1: if n is 1:
2:     return ""1""
3: else:
4:     return countnndSay(n-1) + str(len(countnndSay(n-1))) + countnndSay(n-1)[-1]"
"Input: arr: an array of integers, N: an integer
Output: length: an integer
1: if N is negative:
2:     return 0
3: max_length = 1
4: for i in range(1, N):
5:     if arr[i] < 0:
6:         max_length = i
7: return max_length"
"Input: m: a number, n: a number
Output: normal: a number
1: normal = (abs(m) * abs(n)) / math.sqrt((abs(m) * abs(m)) + (abs(n) * abs(n)))
2: return normal"
"Input: arr: an array of integers, n: length of array, k: target number
Output: count: the count of subarrays whose sum is less than the target number
1: count = 0
2: for i = 0 to n-1:
3:     sum = 0
4:     for j = i to n-1:
5:         sum = sum + arr[j]
6:         if sum < k:
7:             count = count + 1
8: return count"
"Input: n: an integer
Output: count: an integer
1: count = 0
2: for i in range(n):
3:     for j in range(i+1, n):
4:         for k in range(j+1, n):
5:             if arr[k] - arr[i] <= L and arr[k] - arr[j] <= L:
6:                 count += 1
7: return count"
"Input: l: lower bound, r: upper bound
Output: count: the count of numbers between l and r that can be expressed as the product of only 2 and 3.
1: count = 0
2: for i in range(l, r+1):
3:     if i % 2 == 0 and i % 3 == 0:
4:         count += 1
5: return count"
"Input: n: an integer, m: an integer
Output: n: an integer
1: n = n & ( 2^m - 1 )
2: n = n ^ ( 2^m )
3: return n"
"Input: L, R, K
Output: count
1: count = 0
2: for i in range(L, R + 1):
3:     if i % 9 == K or i % 9 == 0:
4:         count += 1
5: return count"
"Input: n: a positive integer, k: a positive integer
Output: str: a string of length k
1: if n is less than 10:
2:     return n
3: else:
4:     return firstkdigits(n//10, k) + str(n%10)"
"Input: A: a list of integers
Output: first_element: the first element in A that is greater than all the elements before it and less than all the elements after it.
1: first_element = A[0]
2: for i in range(1,n):
3:     if A[i] > first_element:
4:         first_element = A[i]
5: return first_element"
"Input: a, b, c
Output: minimum increase needed to make the sum of the two smallest integers greater than or equal to the largest integer.
1: if a + b + c < max(a, b, c):
2:     return max(a, b, c) - (a + b + c)
3: return 0"
